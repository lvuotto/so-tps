\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
\usepackage{makeidx}

\usepackage{float}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{caption}

\usepackage{hyperref} %las entradas del índice tienen links
\hypersetup{
    colorlinks=true,
    linktoc=all,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\input{codesnippet}
\input{page.layout}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}

\usepackage{color}
\usepackage{clrscode3e} % para el pseudocodigo




\begin{document}

\lstset{
  language=C++,
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\thispagestyle{empty}
\materia{Sistemas Operativos}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico I}
%\subtitulo{}
\integrante{Caravario, Martín}{470/12}{martin.caravario@gmail.com}
\integrante{Hosen, Federico}{825/12}{fhosen@hotmail.com}
\integrante{Vuotto, Lucas}{385/12}{lvuotto@dc.uba.ar}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
    \vspace{0.5cm}
    \textcolor{red}{\textbf{completar!}}
\end{abstract}

\thispagestyle{empty}
\vspace{1.5cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Introducción}
En este trabajo práctico se realizarán implementaciones de diversos
schedulers, y se analizará su comportamiento de acuerdo a distintas
métricas. Este analisis será realizado con un simulador proporcionado por la
cátedra, el cual describe los procesos del scheduler en cada uno de los
cores del procesador, en funcion del tiempo.

\subsection{Métricas utilizadas}
Para realizar este trabajo se debieron utilizar diversas métricas con el
objetivo de analizar distintos aspectos del rendimiento y comportamiento de
los schedulers implementados.

Como las distintas métricas nos pueden arrojar diversas conclusiones sobre
qué scheduler es mejor que otro, se procederá a realizar un análisis
riguroso de cada algoritmo de scheduling bajo las diferentes métricas, con
el fin de obtener una mejor comparación y poder ver las ventajas y
desvantajas de cada algoritmo en distintos ámbitos, como ser el tiempo total
de carga del CPU o la cantidad de procesos finalizados respecto al tiempo
total de uso del CPU.

Para tal fin, se decidieron analizar 3 aspectos de cada scheduler:

\begin{itemize}
  \item \textbf{Fairness}: esta métrica, tambien llamada de ecuanimidad,
  captura que tan uniforme es la distribucion del cpu para cada proceso.
  Esto significa que medirá la cantidad de ciclos de CPU que utiliza cada
  proceso, y que tan justa es esa distribución con respecto a los demas. En
  nuestro caso consideramos una distribución justa, que cada proceso tenga
  la misma
  \item \textbf{Throughput}: mide la cantidad de procesos que finalizan por
  unidad de tiempo.
  \item \textbf{Turnaround}: esta métrica muestra el tiempo total que le
  toma a cada proceso en ejecutar completamente, incluídos los tiempos de
  carga y cambios de contexto.
\end{itemize}

Existen otras métricas como por ejemplo el \textit{tiempo de respuesta}, que
se encarga de medir el tiempo de respuesta percibido por el usuario,
que no fueron consideradas a la hora de testear los schedulers ya que
no contabamos con las herramientas necesarias para medir esto. Tampoco
tuvimos en cuenta la medida de \textit{latencia}, la cual mide el tiempo que
necesita un proceso para empezar a dar resultados, debido a que no
conocíamos que hacía cada proceso y no podíamos observar dichos resultados.
\newpage


\section{Ejercicio 1}

\subsection{Explicación del algoritmo}
Para este ejercicio se decidió crear una función llamada \textbf{get\_rand}
a la cual se le pasan los parámetros \textit{bmin} y \textit{bmax}. El
objetivo de esta función es generar un número aleatorio entre \textit{bmin}
y \textit{bmax}, lo cual se lleva de la siguiente manera:

\begin{verbatim}
return rand() % (bmax - bmin + 1) + bmin;
\end{verbatim}

Cabe destacar que utilizamos la funcion \verb|rand|, la cual fue sugerida
por la cátedra, con el fin de generar un numero aleatorio. Esta función es
invocada $n$ veces, siendo $n$ la cantidad de llamados bloqueantes que debe
realizar la tarea, con el fin de generar los números aleatorios que serán
utilizados como la duración de cada llamada.

\section{Ejercicio 2}
En este ejercicio se simulara el scheduler \textit{FCFS} con 3 tareas, una 
intensiva en CPU y las otras dos de tipo TaskConsola. A continuación se
muestra el lote utilizado:
\begin{verbatim}

TaskCPU 12
TaskConsola 0 9 72
TaskConsola 6 1 16

\end{verbatim}

\subsection{Resultados}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.4]{imagenes/ej2-c-1.png}
\end{center}
\caption{Gráfico de los procesos corriendo en un core}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.4]{imagenes/ej2-c-2.png}
\end{center}
\caption{Gráfico de los procesos corriendo en dos cores}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.4]{imagenes/ej2-c-3.png}
\end{center}
\caption{Gráfico de los procesos corriendo en tres cores}
\end{figure}

\newpage

\section{Ejercicio 3: Round Robin}

\subsection{Explicación del algoritmo.}
El tipo de scheduling \textit{round robin} consiste en asignar a cada
proceso un tiempo predeterminado para que se ejecute, llamado
\textit{quantum}. Si el proceso no termina su ejecución antes dicho quantum
se acabe, es desalojado y puesto en una cola (espera circular) para ser
retomada su ejecución luego de atender a los demás procesos en dicha cola.

Este modelo de scheduling permite asegurarse de que no exista la inanición,
pues todos los procesos son atendidos; mas aún, a todos lo
procesos les es asignado el mismo quantum. De esta
forma, round robin es altamente confiable en términos de ecuanimidad.

Para implementarlo utilizamos:
\begin{itemize}
\item una cola \footnote{Implementada con \textit{queue} de la STL de C++.}, de nombre
\textit{ready} que nos indica las tareas en espera para su ejecución.
\item Un vector \footnote{Implementado con
\textit{vector} de la STL de C++.} de enteros \textit{ticks} en el cual
guardamos la cantidad de ciclos restantes para la tarea que está corriendo
en cada núcleo.
\item Un vector de enteros \textit{quantums} donde tenemos
almacenados los quantums correspondientes a cada núcleo. 
\end{itemize}

Dado un núcleo, cuando el elemento de \textit{ticks} correspondiente a dicho
núcleo alcanza el valor $0$, dicho proceso es desalojado y puesto en el
final de la cola, dejando el procesador libre para el próximo en la cola.
Si no existe algún proceso en la cola, el núcleo entra en estado
\textit{idle} hasta que se cargue una nueva tarea.

De igual forma, cuando un proceso se bloquea, es puesto de vuelta en la
cola, y la próxima vez que corra lo hará con el \textit{quantum} entero.
Ésto es, quizás, una de las falencias de esta implementación \textit{naive}
de \textit{round robin} en términos de \textit{fairness}, pues la tarea que
se bloquea \textit{pierde} una porción de su tiempo asignado, que no es
recuperado en su siguiente turno. Una posible modificación a la
implementación para solucionar esto sería añadir algún sistema de
recompensas para las tareas que no terminan su \textit{quantum}.

\section{Ejercicio 4: Simulaciones y análisis de Round Robin}

\subsection{Introducción}
En este ejercicio se analizó el comportamiento del modelo de scheduling
\textit{Round Robin} variando la cantidad de tareas, el quantum, la cantidad
de núcleos y el tiempo de cambio de contexto. Se busca ver cómo estas
variaciones afectan las distintas métricas mencionadas anteriormente, para
así poder arrojar conclusiones sobre este scheduler.

\subsection{Experimento 1: Funcionamiento RR}
En este primer experimento simulamos 8 tareas corriendo simultaneamente en
un procesador de un solo núcleo, fijando el costo de cambio de contexto en 1
y el quantum en 5 ciclos de \textit{clock}. El tiempo en el que cada tarea
pasaba a estado \textit{ready} fue elegido pseudoaleatoriamente.

El objetivo de este experimento fue verificar que la implementación se
comporte en efecto como un scheduler round robin, es decir, que siga el
comportamiento mencionado en el ejercicio 3.

Primero se simuló un lote de 8 tareas de uso intensivo del CPU y luego un
lote de 8 tareas varias (uso intensivo y uso interactivo). Ambos lotes se
simularon según las condiciones explicadas previamentes.

El lote de tareas utilizado fue el siguiente:

\begin{verbatim}
TaskCPU 15
TaskCPU 11
TaskCPU 25
TaskCPU 24
TaskCPU 10
TaskCPU 16
TaskCPU 13
TaskCPU 22
\end{verbatim}

\textbf{\textcolor{red}{PONER EL OTRO LOTE}}

\subsubsection{Resultados}
\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.4]{imagenes/ej4-1.png}
\end{center}
\caption{Experimento 1. Lote 8 tareas. Quantum 5.}
\end{figure}

\subsubsection{Conclusión}

\textcolor{red}{\textbf{DEBATIR ESTE PÁRRAFO}}

Como era de esperarse, empieza a ejecutarse el primer proceso \textit{listo}
hasta cumplir su cuota de tiempo, luego pasa a ejecutar al siguiente, y así
hasta retomar la primer tarea (pues se turnan de manera circular). A medida
que los procesos terminan la totalidad de su ejecución, la cola se va
haciendo más corta, acortando el tiempo de espera entre el desalojo de un
proceso y su retorno. Ésto se repite hasta que todos los procesos terminan
su ejecución.

\subsection{Experimento 2: Impacto del quantum}
Con este experimento se logró analizar el impacto del tamaño del quantum en
el tiempo necesario para terminar de ejecutar cada tarea. Asignar un quantum
muy bajo haría que dicho tiempo aumente, dado que habrá más ciclos de
\textit{clock} dedicados a realizar los cambios de contextos, aumentando el
tiempo total que le toma a cada tarea terminar su ejecución,
\textcolor{red}{\textbf{WTF}} pero si este es demasiado alto podría generar
que el tiempo de respuesta percibido sea muy alto, pero como no nos interesa
medir esta métrica, no lo tendremos en cuenta.

Analizaremos primero comparativamente en un procesador de un núcleo, con el
mismo lote de tareas, variando el quantum.

Procesador de 1 núcleo, con un quantum de valor 2.

Procesador de 1 núcleo, con un quantum de valor 7.

Procesador de 1 núcleo, con un quantum de valor 15.

Ahora analizamos comparativamente en un procesador de 4 núcleos, manteniendo
el mismo lote de tareas, y tomando los mismo valores de quantum (en 3
simulaciones distintas).

Procesador de 4 núcleos, con un quantum de valor 2.

Procesador de 4 núcleos, con un quantum de valor 7.

Procesador de 4 núcleos, con un quantum de valor 15.

\subsubsection{Conclusión}

\section{Ejercicio 5: Lottery Scheduling}
\subsection{Explicación del algoritmo}
El modelo de scheduling \textit{Lottery} consiste en tener un sistema
pseudoaleatorio que decida cual va a ser el siguiente proceso a ser
ejecutado. Esto lo hace \textit{repartiendo tickets} a cada proceso, y
generando un ticket ganador al azar. Así, cada
proceso va a tener asociado una cantidad de tickets, obteniendo
cierta probabilidad de ganar la lotería. De esta forma, el proceso con más
tickets tiene más probabilidades de ganar. Éste es el mecanismo que nos
permite establecer relaciones de prioridades entre procesos.
Y como dado un número entre $1$ y $n$, la posibilidad de que dicho número
\textbf{no} salga nunca es $0$, eventualmente el número será elegido por el
algoritmo de scheduling. De esta forma, no hay \textit{inanición}, pues
todo proceso será puesto a correr en algún momento.

Para implementarlo utilizamos:
\begin{itemize}
\item Una lista de procesos y sus tickets, \textbf{procesos}
\footnote{Utilizamos list(pair(int,int)) de la STL de C++.}.
\item Un diccionario de procesos bloqueados, \textbf{bloqueados}
\footnote{Utilizamos map(int,int) de la STL de C++.}, que dado un pid guarda con cuantos
tickets tiene que regresar.
\item Una variable entera \textbf{ciclos}, que especifica cuantos ciclos
consumió el proceso actual (el que ocupa el procesador).
\item Una variable entera \textbf{quantum}.
\item Una variable entera \textbf{tickets}, que indica la cantidad de
tickets totales asignados.
\end{itemize}

La implementación hecha está basada en la mencionada en el paper. Se utiliza
una lista enlazada para guardar los procesos y sus respectivos tickets.
Inicialmente a todos los procesos se les asigna 1 ticket, teniendo todos las
mismas posibilidades de \textit{salir sorteados}; es interesante notar que
dicho número podría ser cualquiera, mientras sea el mismo para todos, ya que
mantiene la relación de igual prioridad para todos los procesos.

A medida que algunos procesos cambian al estado \textit{bloqueado}, la
cantidad de tickets de éste aumenta en proporción a la fracción de quantum que usó. Al
bloquearse, es agregado al diccionario \textit{bloqueados}, con su pid y
su nueva cantidad de tickets. Luego, al ser desbloqueado, es puesto de nuevo
en la lista con su nueva cantidad de tickets, que es estrictamente mayor a
la cantidad anterior.

Para saber qué proceso debe correr, el scheduler genera un número
aleatorio entre $0$ y $n-1$ \footnote{Siendo $n$ la suma total de tickets}, y luego recorre linealmente la lista de
procesos. Al ir recorriendola, acumula la cantidad de tickets de los
elementos que visita, y cuando dicha suma alcanza el valor generado
ganador se encuentra al ganador.

Una optimización adoptada del paper fue mantener la lista ordenada
decrecientemente, de forma tal que al sacar el número ganador y recorrer la
lista acumulando la sumatoria hasta alcanzar a dicho número, se minimize el
recorrido. Ésto se debe a que los primeros valores son los más grandes,
entonces el valor acumulado aumenta de la forma más rapida posible,
corriendo menos iteraciones para alcanzar dicho valor. Aunque en el peor
caso, el ticket ganador es el $n-1$, con lo cual no importa cómo esté
ordenada la lista, para encontrar al ganador, la lista deberá ser recorrida
hasta el final.

La transferencia de tickets propuesta por el paper no fue implementada, ya que
los procesos simulados en este trabajo no interactúan con otros, con lo cual
no tiene sentido transferir prioridades para mejorar la dependencia entre
procesos. Por la misma razón, tampoco fue implementada la inflación de
tickets, ya que cumple una función similar.

El modelo de \textit{tickets currencies} tampoco fue utilizado, ya que
éste apunta al manejo de recursos compartidos por un grupo de procesos,
situación que no se presenta en estas simulaciones.

\section{Ejercicio 6}

\subsection{Explicación del algoritmo}
Para llevar a cabo el algoritmo se precalculó aleatoriamente en que ciclos
de \textit{clock} el proceso debe bloquearse. Para esto reutilizamos la
función \verb|get_rand| utilizada en el ejercicio 1, con el objetivo de
generar un número pseudoaleatorio entre 0 y la cantidad de ciclos de CPU que
consumirá el proceso. Este número fue utilizado para saber en qué ciclo el
proceso debe bloquearse. Para esto se generó un vector de booleanos (del
tamaño de la cantidad de ciclos que corre la tarea) el cual se llenó en las
posiciones devueltas por la función \verb|get_rand|.

Luego de esto el algoritmo recorre el vector de booleanos y se fija si en
el ciclo actual debe bloquearse o utilizar CPU, según lo que diga esa
posición indexada del vector. 

Cada tarea se bloqueará por un ciclo de \textit{clock}, asegurando así que
el tiempo total utilizado por la tarea es de \textit{total\_cpu} ciclos,
tal como lo pide el enunciado.


\section{Ejercicio 7}

\newpage

\section{Ejercicio 8}

\subsection{Explicación del algoritmo}
Para poder llevar a cabo un scheduler \textit{Round Robin} sin migración
entre núcleos, se modificó levemente la implementación del ejercicio 3 para
lograr abstraer cada núcleo. Para eso se creó la estructura
\verb|core_info|, la cual está compuesta por

\begin{itemize}
  \item el quantum asignado al procesador, \textit{quantum},
  \item la cantidad de procesos bloqueados, \textit{bloqueados},
  \item la cola de procesos listo para ejecutar, \textit{ready},
  \item la cantidad de ciclos de \textit{clock} consumidos por el proceso en
  ejecución, \textit{ciclos} y
  \item un booleano que informa si hay o no un proceso ejecutandose,
  \textit{corriendo}.
\end{itemize}

Una vez decidida la asignación de los procesos a cada núcleo, al observarse
el comportamiento del nuevo scheduler sobre cada núcleo, este es el mismo
que un \textit{Round Robin} estándar corriendo en un procesador de un solo
núcleo.

Para decidir en qué núcleo cargar cada tarea, se procede a realizar una
simple cuenta: se suman la cantidad procesos listos para correr con la
cantidad de tareas bloqueadas y $1$ o $0$, dependiendo de si hay o no alguna
tarea en ejecución en el núcleo. Una vez obtenido este resultado para cada
núcleo, la tarea en cuestión es cargada en el núcleo que minimice dicho
resultado.



\end{document}
